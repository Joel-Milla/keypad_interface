/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


// Prototypes
void findConnectionCx(uint8_t, uint32_t volatile *const);
void delay(void);
uint8_t getCharacter(uint8_t, uint8_t);

/*
 * The pins that are going to be used as output are PD0-PD3 for the row ports (R1-R4). The pins are free to use
 * The pins that are going to be used as input are PD8-PD11 for the column ports (C1-C4). The pins are free to use
*/

int main(void)
{
	// 1. Initialize required variables to handle memory-mapped registers with appropriate register addresses
	uint32_t volatile *const pAHB1ClockEnableRegister = (uint32_t *) 0x40023830; // Memory address of RCC to enable the clock
	uint32_t volatile *const pGPIODPortModeRegister = (uint32_t *) 0x40020C00; // Memory address to change the port modes (input/output/etc) of the pins in GPIOD
	uint32_t volatile *const pGPIODPullRegister = (uint32_t *) 0x40020C0C; // Memory address to change to pull up/down registers on specific pins
	uint32_t volatile *const pGPIODOutputDataRegister = (uint32_t *) 0x40020C14; // Memory address to change the output of pins
	uint32_t volatile *const pGPIODInputDataRegister = (uint32_t *) 0x40020C10; // Memory address to read if there is any input in the pins

	// 2. Initialize the clock register for the port that has the pins that will be used (GPIOD)
	*pAHB1ClockEnableRegister |= (1 << 3); // Set the third bit of GPIOD to on to enable clock

	// 3. Initialization of variables and setup of environment for the MCU
	// a. Make all row IOs mode as output (PD0-PD3)
	*pGPIODPortModeRegister &= ~(0xFF); // clear the first 8 bits
	*pGPIODPortModeRegister |= 0x55; // Set the first 8 bits to 01010101
	// b. Make all column IOs mode as input (PD8-PD11)
	*pGPIODPortModeRegister &= ~(0xFF << 16); // Clear the PD8-PD11 to set as input
	// c. Activate internal pull-up resistors for columns IOs (PD8-PD11)
	*pGPIODPullRegister &= ~(0xFF << 16); // Clear all the 8 bits there
	*pGPIODPullRegister |= (0x55 << 16); // Set PD8-PD11 as pull up

	// 4. Implement the key detect logic
	while (1) {
		// a. Set all row outputs as high
		*pGPIODOutputDataRegister = (uint16_t) 0x0F;

		for (uint8_t volatile pinIterator = 0; pinIterator < 4; pinIterator++) {
			// b. Set Ri (i = pinIterator) as low
			*pGPIODOutputDataRegister &= ~(1 << pinIterator);
			// c. Check what column changed to zero (C1-C4) - To confirm if those are the pressed key
			findConnectionCx(pinIterator, pGPIODInputDataRegister);
			// d. Reset the outputs so the printing is done correctly
			*pGPIODOutputDataRegister = (uint16_t) 0x0F;
		}
	}
}

// Function that makes a delay when printing the values
void delay()
{
	// Make a delay using a for loop
	for(uint32_t volatile iterator; iterator < 300000; iterator++); // Causes 150miliseconds = 0.15 seconds
}

// Finds which column is matched with the row called
void findConnectionCx(uint8_t row, uint32_t volatile *const pGPIODInputDataRegister)
{
	// Check which column is on
	uint8_t C0IsOn = !( *pGPIODInputDataRegister & (1 << 8) );
	uint8_t C1IsOn = !( *pGPIODInputDataRegister & (1 << 9) );
	uint8_t C2IsOn = !( *pGPIODInputDataRegister & (1 << 10) );
	uint8_t C3IsOn = !( *pGPIODInputDataRegister & (1 << 11) );

	uint8_t columnOn = C0IsOn ? 0 : C1IsOn ? 1 : C2IsOn ? 2 : C3IsOn ? 3 : 255; // Check which column is the one in the ground. 255 if there is no column on
	if (columnOn != 255) {
		delay(); // Apply delay before printing
		// Print only when a column is on
		printf("%c\n", getCharacter(row, columnOn));
	}
}

// Returns the character that matches the row and the column
uint8_t getCharacter(uint8_t row, uint8_t column)
{
	switch(row) {
	case 0:
		if (column == 0) {
			return '1';
		} else if (column == 1) {
			return '2';
		} else if (column == 2) {
			return '3';
		} else {
			return 'A';
		}
	case 1:
		if (column == 0) {
			return '4';
		} else if (column == 1) {
			return '5';
		} else if (column == 2) {
			return '6';
		} else {
			return 'B';
		}
	case 2:
		if (column == 0) {
			return '7';
		} else if (column == 1) {
			return '8';
		} else if (column == 2) {
			return '9';
		} else {
			return 'C';
		}
	case 3:
		if (column == 0) {
			return '*';
		} else if (column == 1) {
			return '0';
		} else if (column == 2) {
			return '#';
		} else {
			return 'D';
		}
	default:
		return 255;
	}
}











